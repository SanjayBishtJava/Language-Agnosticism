# Language Agnostic

## Why do we have so many programming languages?
In the beginning, there was nothing. Then came about massive advancements in computers at Bletchley Park, and with these advancements came the first methods for programming computers:
Pushing Buttons that represent binary numbers
Then someone said “hey, if we run the same code a few times, why do we have to push a button each time” and so came punch cards.

Then people realised that they could run a program on a computer that will let them write code there. Thus, FORTRAN and Lisp were born. These were the first programming languages, but they were very complicated and hard to use.

As time advanced, computers became stronger and more people wanted to program. Some people decided that it would be better to create newer, more powerful languages, and thus came about c, COBOL, Basic, and many others.

But that wasn't it. People wanted simpler and more powerful programming languages, bringing about Java and C++.

And yet, both Java and C++ are archaic by modern standards. Microsoft created a platform called .NET and merged it with Java and C++ into C#, merged .NET with BASIC to get Visual Basic, and later other programming languages, some of which took off, others which did not.

But take C# and take a modern language like Go, Rust, and Python, all of which seem to be simpler than C#.

Underlying this fact is that all of these languages serve the same purpose: to turn human thoughts into the 1’s and 0’s that the computer understands. In highfalutin computer terms, they are all “Turing complete”.

At their most foundational level, these languages are all the same. But on the surface – where humans interact with them – they vary a lot. This is where other concerns come into play.


## What does language agnosticism mean?
It may sound scary at first, but all it means is more or less language independence. That is, your ability as a software engineer should not be limited to a very specific set of languages. Instead, you should be able to quickly learn new paradigms which fit your needs and use them effectively. In particular, I argue that software engineering is not simply about writing code: it's about architecting a correct and well-designed solution to a problem. As a result, code is merely an expressive tool for realizing the engineering task you just performed.

## Why should you be language agnostic?
1. You become a complete software engineer rather than simply being a Java developer or C++ developer.
2. Helps figure out how to use certain language features effectively
3. Gives rise to nimble thinking.When you know various languages, you tend to get the knack for finding quick solutions to future problems. The reason for this is well justified. Since you can think about your problem in several frameworks, chances are high for you to find a cleaner and effective solution to your problem.
4. A language agnostic software developer is a happy software developer

## How to become language agnostic?
 -  Step1 - Code in differnt programming languages.
 -  Step2 - Understand and implement differnt programming paradigms. 
 -  Step3 - Implement different algorithms in various programming languages.
 -  Step4 - Implement webapps, webapp internals in different programming languages.
 -  Step5 - Implement Best practices in different programming languages.
### Approach
This repo contains branches for every language. 
Every branch will have folders With implementations like
1. Language Basics
2. Algorithms.
3. Programming paradigms
4. Webapp Internals
4. Blockchain Internals

Problem statements and their solutions will be defined in separate git repositories like
1. Language Basics - (https://github.com/mankenavenkatesh/ProgrammingLanguage)
2. Algorithms. (https://github.com/mankenavenkatesh/algorithms)
3. Programming Paradigms (https://github.com/mankenavenkatesh/ProgrammingParadigms)
4. Webapp-internals (https://github.com/mankenavenkatesh/webapp-internals)
5. Blockchain Internals (https://github.com/mankenavenkatesh/blockchain-internals)

and refered to above folders.
